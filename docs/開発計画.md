# スピードマッチ 開発計画

## 📋 開発方針

### 基本戦略
- **AI駆動開発**: GitHub Copilot等のAIアシスタントを最大限活用
- **段階的リリース**: 各フェーズで動作可能な状態を保つ
- **3時間/フェーズ**: 集中して完了できる小さな単位に分割
- **CI/CD自動化**: プッシュで自動デプロイ
- **フロントエンド先行**: モックデータで先行開発し、後からバックエンド統合

### 開発環境
- フロントエンド: React + TypeScript + Vite
- バックエンド: Node.js + Express + PostgreSQL
- インフラ: Docker Compose (ローカル), AWS (本番)
- バージョン管理: Git + GitHub
- CI/CD: AWS CodePipeline

---

## 🎯 フェーズ別開発計画

### Phase 0: 環境構築・準備 ⏱️ 2時間
**目標**: 開発環境の整備と基本設計の確認

#### 作業内容
- [x] プロジェクト構造の確認
- [x] 設計ドキュメントのレビュー
- [x] フロントエンド開発サーバーの起動確認
- [ ] ESLintの設定確認
- [ ] コンポーネント設計の確認
- [x] 開発計画書の作成（本ドキュメント）

#### 成果物
- 開発計画書
- 環境確認完了

#### リリース内容
- ドキュメント追加のみ

---

### Phase 0.5: バックエンドCI/CD・EC2環境構築 ⏱️ 3時間
**目標**: Kotlin + Ktorの最小構成とCI/CDパイプライン構築

#### 作業内容
- [x] Kotlin + Ktorプロジェクト初期化
  - [ ] api/ディレクトリにGradleプロジェクト作成
  - [ ] build.gradle.kts設定
    - Ktorプラグイン
    - Kotlinx.serialization
    - Logback
  - [ ] Application.ktの作成
    - ヘルスチェックエンドポイント (GET /health)
    - Hello Worldエンドポイント (GET /api/hello)
  - [ ] application.conf設定
- [x] Dockerfile作成
  - [ ] マルチステージビルド
  - [ ] JDK 17ベース
  - [ ] ポート8080公開
- [ ] EC2設定
  - [ ] EC2インスタンス確認・起動
  - [ ] セキュリティグループ設定（ポート8080追加）
  - [ ] Dockerインストール確認
  - [ ] デプロイディレクトリ作成 (/home/ec2-user/speedmatch-api)
- [x] EC2自動停止スクリプト
  - [ ] CloudWatch Eventsでスケジュール設定
  - [ ] Lambda関数作成（毎朝5時にEC2停止）
  - [ ] IAMロール設定
  - [ ] 動作確認
- [x] CI/CDパイプライン構築
  - [ ] buildspec-api.yml作成
    - Kotlinビルド
    - Dockerイメージビルド
    - EC2へのデプロイスクリプト
  - [x] CodePipeline更新
    - 既存のフロントエンドパイプラインに追加
    - api/以下の変更を検知
    - CodeBuildでビルド
    - EC2へSSHデプロイ
  - [x] デプロイスクリプト作成
    - deploy-api.sh
    - docker-compose.yml（本番用）
- [x] 動作確認
  - [ ] ローカルでKtorサーバー起動
  - [ ] /health, /api/helloにアクセス確認
  - [ ] Gitプッシュ → CI/CD実行確認
  - [ ] EC2での動作確認

#### 成果物
- Kotlin + Ktorの最小プロジェクト
- Dockerfile
- buildspec-api.yml
- デプロイスクリプト
- EC2自動停止Lambda関数
- CI/CDパイプライン

#### リリース内容
- バックエンドAPIが本番環境で起動
- http://EC2_IP:8080/health にアクセス可能
- http://EC2_IP:8080/api/hello で "Hello, SpeedMatch!" を返す
- 毎朝5時に自動停止

#### AI活用ポイント
- Gradle設定の生成
- Ktor最小構成の実装
- buildspec.ymlの生成
- Lambda関数の生成（Python/Node.js）
- デプロイスクリプトの作成

#### 技術詳細

##### Lambda関数（EC2自動停止）
```python
# lambda_stop_ec2.py
import boto3

def lambda_handler(event, context):
    ec2 = boto3.client('ec2', region_name='ap-northeast-1')
    
    # EC2インスタンスID（環境変数から取得）
    instance_id = 'i-xxxxxxxxx'
    
    # インスタンス停止
    ec2.stop_instances(InstanceIds=[instance_id])
    
    return {
        'statusCode': 200,
        'body': f'Stopped EC2 instance: {instance_id}'
    }
```

##### buildspec-api.yml
```yaml
version: 0.2

phases:
  pre_build:
    commands:
      - echo Logging in to Docker Hub...
      - cd api
  build:
    commands:
      - echo Build started on `date`
      - ./gradlew clean build
      - docker build -t speedmatch-api:latest .
  post_build:
    commands:
      - echo Build completed on `date`
      - echo Deploying to EC2...
      - chmod +x ../scripts/deploy-api.sh
      - ../scripts/deploy-api.sh

artifacts:
  files:
    - '**/*'
```

##### デプロイスクリプト
```bash
#!/bin/bash
# deploy-api.sh

EC2_HOST="ec2-user@xx.xx.xx.xx"
DEPLOY_DIR="/home/ec2-user/speedmatch-api"

# Dockerイメージをtar化して転送
docker save speedmatch-api:latest | ssh $EC2_HOST "docker load"

# docker-compose.ymlを転送
scp docker-compose.prod.yml $EC2_HOST:$DEPLOY_DIR/docker-compose.yml

# EC2でコンテナ再起動
ssh $EC2_HOST "cd $DEPLOY_DIR && docker-compose down && docker-compose up -d"
```

---

### Phase 1: 基本レイアウト・デザインシステム ⏱️ 3時間
**目標**: 共通コンポーネントと基本レイアウトの実装

#### 作業内容
- [x] デザインシステムの実装
  - [x] カラーパレット定義
  - [x] タイポグラフィ設定
  - [x] ボタンコンポーネント
  - [x] カードコンポーネント
  - [x] 入力フォームコンポーネント
- [ ] レイアウトコンポーネント
  - [ ] Header
  - [ ] Footer
  - [ ] Container
  - [ ] Grid system
- [ ] ルーティング設定（React Router）
- [ ] 基本的なページ構造

#### 成果物
- 共通コンポーネントライブラリ
- 基本レイアウト
- ルーティング設定

#### リリース内容
- デザインシステムのデモページ
- 各画面への遷移が可能な骨組み

#### AI活用ポイント
- デザインシステムドキュメントを元にコンポーネント生成
- スタイリングの一括生成

---

### Phase 2: プレイヤー登録・管理機能 ⏱️ 3時間
**目標**: ローカルストレージでプレイヤー情報を管理

#### 作業内容
- [ ] プレイヤー登録画面
  - [ ] 名前入力フォーム（バリデーション付き）
  - [ ] アバター選択UI
  - [ ] 登録処理
- [ ] LocalStorage管理
  - [ ] プレイヤー情報の保存/読込
  - [ ] Context APIでの状態管理
- [ ] プレイヤー情報編集画面
  - [ ] 編集フォーム
  - [ ] 更新処理
- [ ] ヘッダーにプレイヤー情報表示

#### 成果物
- プレイヤー登録・編集機能
- LocalStorageユーティリティ
- グローバル状態管理

#### リリース内容
- プレイヤーを作成して名前とアバターを設定可能
- ページをリロードしても情報が保持される

#### AI活用ポイント
- バリデーションロジックの生成
- LocalStorageユーティリティの実装
- Context APIのボイラープレート生成

---

### Phase 3: メイン画面・ルーム一覧（モック） ⏱️ 3時間
**目標**: モックデータでルーム一覧を表示

#### 作業内容
- [ ] メイン画面（ロビー）の実装
  - [ ] ルーム作成ボタン
  - [ ] ルーム参加ボタン
  - [ ] コード入力ダイアログ
- [ ] ルーム一覧表示
  - [ ] ルームカードコンポーネント
  - [ ] フィルター機能（人数、状態）
  - [ ] 更新ボタン
- [ ] モックデータの作成
  - [ ] ルームデータ
  - [ ] プレイヤーデータ
- [ ] ルーム検索機能

#### 成果物
- メイン画面
- ルーム一覧表示機能
- モックデータセット

#### リリース内容
- ルーム一覧の閲覧が可能
- フィルタリング・検索が動作
- ダミーデータでUI確認可能

#### AI活用ポイント
- モックデータの自動生成
- フィルタリングロジックの実装
- レスポンシブデザインの調整

---

### Phase 4: ルーム作成・待機画面 ⏱️ 3時間
**目標**: ルーム作成とルーム待機画面の実装

#### 作業内容
- [ ] ルーム作成画面
  - [ ] 設定フォーム（人数、手札枚数、時間制限等）
  - [ ] 公開/非公開トグル
  - [ ] ルームコード生成
  - [ ] 作成処理（LocalStorage）
- [ ] ルーム待機画面
  - [ ] 参加者リスト表示
  - [ ] ルームコード表示・コピー機能
  - [ ] ルーム設定表示
  - [ ] 退出ボタン
  - [ ] 準備完了ボタン
- [ ] ルーム状態管理
  - [ ] Context APIでルーム情報管理
  - [ ] 参加者の追加/削除（モック）

#### 成果物
- ルーム作成機能
- ルーム待機画面
- ルーム状態管理

#### リリース内容
- ルームを作成して待機画面に遷移
- ルーム設定が正しく反映される
- ルームコードのコピーが可能

#### AI活用ポイント
- フォームバリデーションの実装
- ルームコード生成ロジック
- 状態管理の複雑なロジック

---

### Phase 5: ゲーム画面UI（静的） ⏱️ 3時間
**目標**: ゲーム画面のUIを実装（ロジックなし）

#### 作業内容
- [ ] ゲーム画面レイアウト
  - [ ] 場のカード表示エリア
  - [ ] 手札エリア
  - [ ] 他プレイヤー情報エリア
  - [ ] ターン表示
  - [ ] タイマー表示
- [ ] カードコンポーネント
  - [ ] カードデザイン（1-13）
  - [ ] ホバーエフェクト
  - [ ] クリック/ドラッグアニメーション
- [ ] プレイヤーステータス表示
  - [ ] アバター
  - [ ] 残り手札数
  - [ ] ターンインジケーター
- [ ] モックデータでの表示確認

#### 成果物
- ゲーム画面UI
- カードコンポーネント
- アニメーション

#### リリース内容
- ゲーム画面の見た目が完成
- カードの表示とアニメーションが動作
- モックデータでゲーム中の様子を確認可能

#### AI活用ポイント
- カードデザインのCSS生成
- アニメーションロジック
- レスポンシブレイアウト

---

### Phase 6: バックエンド基盤構築 ⏱️ 3時間
**目標**: Ktor + PostgreSQL環境の構築

#### 作業内容
- [ ] Kotlinプロジェクトの作成
  - [ ] api/ディレクトリ構造
  - [ ] Gradle設定（build.gradle.kts）
  - [ ] 依存関係の追加（Ktor, Exposed, PostgreSQL）
- [ ] Ktor APIサーバー構築
  - [ ] 基本的なサーバー設定（Application.kt）
  - [ ] プラグイン設定（ContentNegotiation, CORS, CallLogging）
  - [ ] ルーティング基本構造
  - [ ] エラーハンドリング
  - [ ] ヘルスチェックエンドポイント
- [ ] Docker Compose設定
  - [ ] PostgreSQL設定
  - [ ] Ktor API設定（Dockerfile）
  - [ ] Nginx設定（開発用）
- [ ] データベース接続
  - [ ] Exposed設定
  - [ ] PostgreSQL接続設定
  - [ ] コネクションプール

#### 成果物
- Ktor APIサーバー
- Docker Compose環境
- Exposed ORMセットアップ
- データベース接続

#### リリース内容
- バックエンドAPIが起動
- ヘルスチェックエンドポイントにアクセス可能
- データベース接続確認

#### AI活用ポイント
- Gradle設定の生成
- Ktor定型コードの生成
- Exposed設定の実装

---

### Phase 7: データベーススキーマ実装 ⏱️ 3時間
**目標**: テーブル作成とExposed Entity定義

#### 作業内容
- [ ] Exposed Tableオブジェクト定義
  - [ ] Playersテーブル
  - [ ] Roomsテーブル
  - [ ] RoomPlayersテーブル
  - [ ] Gamesテーブル
  - [ ] GamePlayersテーブル
  - [ ] GameActionsテーブル
  - [ ] ChatMessagesテーブル
- [ ] インデックス・制約の設定
- [ ] スキーマ自動作成設定
  - [ ] SchemaUtils.create()
- [ ] シードデータ作成
  - [ ] テスト用プレイヤー
  - [ ] テスト用ルーム
- [ ] DTO（Data Transfer Object）クラス定義

#### 成果物
- Exposed Tableオブジェクト
- Entityクラス
- DTOクラス
- シードデータ

#### リリース内容
- データベーステーブルが作成される
- テストデータで動作確認可能

#### AI活用ポイント
- DB設計書からExposed Table定義生成
- DTO自動生成
- リレーション設定の実装

---

### Phase 8: プレイヤーAPI実装 ⏱️ 3時間
**目標**: プレイヤー関連のCRUD API

#### 作業内容
- [ ] プレイヤーAPIエンドポイント（Ktor Routing）
  - [ ] POST /api/players - プレイヤー登録
  - [ ] GET /api/players/:id - プレイヤー情報取得
  - [ ] PUT /api/players/:id - プレイヤー情報更新
  - [ ] GET /api/players/:id/stats - 統計情報取得
- [ ] サービスレイヤー実装
  - [ ] PlayerService.kt
  - [ ] トランザクション処理
- [ ] バリデーション実装
  - [ ] 入力チェック（kotlinx.validation）
  - [ ] 重複チェック
- [ ] エラーレスポンス統一
  - [ ] 例外ハンドリング
- [ ] APIテスト作成（IntelliJ HTTP Client / Postman）

#### 成果物
- プレイヤーAPI
- PlayerServiceクラス
- バリデーションロジック
- APIドキュメント

#### リリース内容
- プレイヤーAPIが動作
- フロントエンドから呼び出し可能

#### AI活用ポイント
- Ktor Routing定義の生成
- Exposed DAOパターンの実装
- バリデーションルールの実装

---

### Phase 9: フロントエンド・バックエンド統合（プレイヤー） ⏱️ 3時間
**目標**: プレイヤー機能をAPIに接続

#### 作業内容
- [ ] API通信設定
  - [ ] axiosセットアップ
  - [ ] APIクライアント作成
  - [ ] エラーハンドリング
- [ ] プレイヤー機能の統合
  - [ ] LocalStorageからAPI移行
  - [ ] 登録処理の修正
  - [ ] 編集処理の修正
  - [ ] 統計情報取得
- [ ] ローディング状態の実装
- [ ] エラー表示の実装

#### 成果物
- API統合されたプレイヤー機能
- エラーハンドリング

#### リリース内容
- プレイヤー情報がサーバーに保存される
- 統計情報がバックエンドから取得される

#### AI活用ポイント
- API通信ロジックの生成
- 非同期処理のエラーハンドリング
- ローディングUIの実装

---

### Phase 10: ルームAPI実装 ⏱️ 3時間
**目標**: ルーム関連のAPI実装

#### 作業内容
- [ ] ルームAPIエンドポイント（Ktor Routing）
  - [ ] POST /api/rooms - ルーム作成
  - [ ] GET /api/rooms - ルーム一覧取得
  - [ ] GET /api/rooms/:roomCode - ルーム情報取得
  - [ ] POST /api/rooms/:roomCode/join - ルーム参加
  - [ ] DELETE /api/rooms/:roomCode/leave - ルーム退出
  - [ ] PUT /api/rooms/:roomCode/ready - 準備完了
- [ ] RoomServiceクラス実装
  - [ ] ルーム状態管理ロジック
  - [ ] トランザクション処理
- [ ] ルームコード生成・検証
- [ ] 参加者管理ロジック

#### 成果物
- ルームAPI
- RoomServiceクラス
- ルーム管理ロジック

#### リリース内容
- ルーム作成・参加がAPIで動作
- ルーム一覧がデータベースから取得される

#### AI活用ポイント
- ルーム管理の複雑なロジック
- Exposedトランザクション処理
- 同時実行制御（synchronized/Mutex）

---

### Phase 11: ポーリング機能実装 ⏱️ 3時間
**目標**: 定期的なAPIポーリングでリアルタイム風の更新を実現

#### 作業内容
- [ ] ポーリング用APIエンドポイント
  - [ ] GET /api/rooms/:roomCode/state - ルーム状態取得
  - [ ] GET /api/games/:gameId/state - ゲーム状態取得
  - [ ] 差分データの返却（Last-Modified対応）
- [ ] フロントエンドポーリング機構
  - [ ] usePollingカスタムHook作成
  - [ ] 自動リトライ機能
  - [ ] エラーハンドリング
- [ ] 状態変更検知
  - [ ] タイムスタンプ管理
  - [ ] 変更があった場合のみデータ返却
- [ ] ポーリング間隔の最適化
  - [ ] 待機中: 2秒間隔
  - [ ] ゲーム中: 1秒間隔
  - [ ] バックグラウンド: 5秒間隔

#### 成果物
- ポーリング用APIエンドポイント
- usePollingカスタムHook
- 状態管理ロジック

#### リリース内容
- 定期的にルーム情報が更新される
- 参加者の増減が自動的に反映される
- ネットワーク負荷を抑えた実装

#### AI活用ポイント
- 効率的なポーリングロジック
- カスタムHookの実装
- キャッシュ戦略の実装

---

### Phase 12: ルーム待機画面のポーリング対応 ⏱️ 3時間
**目標**: 待機画面をポーリングで更新

#### 作業内容
- [ ] ポーリング統合
  - [ ] ルーム参加時にポーリング開始
  - [ ] usePolling Hookの適用
  - [ ] 退出時にポーリング停止
- [ ] 自動更新実装
  - [ ] 参加者リストの自動更新
  - [ ] 準備状態の同期
  - [ ] ルーム設定の同期
- [ ] チャット機能実装
  - [ ] POST /api/rooms/:roomCode/messages - メッセージ送信
  - [ ] GET /api/rooms/:roomCode/messages - メッセージ取得（ポーリング）
  - [ ] メッセージ表示
  - [ ] チャット履歴
- [ ] ゲーム開始処理（ホストのみ）
  - [ ] POST /api/rooms/:roomCode/start

#### 成果物
- ポーリング対応ルーム待機画面
- チャット機能

#### リリース内容
- 複数ブラウザで同時に待機画面を開いて同期確認
- チャットでコミュニケーション（2秒遅延）
- 全員準備完了でゲーム開始可能

#### AI活用ポイント
- ポーリングベースの状態同期
- チャット実装
- 状態管理の最適化

---

### Phase 13: ゲームロジック実装（バックエンド） ⏱️ 3時間
**目標**: ゲームのコアロジックをKotlinで実装

#### 作業内容
- [ ] ゲームロジッククラス作成
  - [ ] GameEngine.kt
  - [ ] Card.kt（データクラス）
  - [ ] GameState.kt
- [ ] ゲーム初期化
  - [ ] デッキ生成・シャッフル
  - [ ] 手札配布
  - [ ] 初期場札設定
- [ ] ゲームルールエンジン
  - [ ] カード出せるか判定（isValidMove）
  - [ ] ターン管理
  - [ ] 勝利判定
- [ ] ゲーム状態管理
  - [ ] 各プレイヤーの手札（JSON保存）
  - [ ] 場のカード
  - [ ] ターン順序
- [ ] ゲームアクション処理
  - [ ] カードプレイ
  - [ ] ターンスキップ
  - [ ] ドロー処理
- [ ] ユニットテスト（KotlinTest）

#### 成果物
- GameEngineクラス
- ゲーム状態管理
- ユニットテスト

#### リリース内容
- ゲームロジックのテストが通過
- APIでゲーム操作が可能

#### AI活用ポイント
- Kotlinでのゲームロジック実装
- データクラスの活用
- KotlinTestの実装

---

### Phase 14: ゲームAPI実装 ⏱️ 3時間
**目標**: ゲームプレイのAPI実装

#### 作業内容
- [ ] ゲームAPIエンドポイント（Ktor Routing）
  - [ ] POST /api/games - ゲーム開始
  - [ ] GET /api/games/:gameId/state - ゲーム状態取得（ポーリング用）
  - [ ] POST /api/games/:gameId/actions/play - カードプレイ
  - [ ] POST /api/games/:gameId/actions/skip - ターンスキップ
  - [ ] POST /api/games/:gameId/actions/draw - カードドロー
- [ ] GameServiceクラス実装
  - [ ] GameEngineとの連携
  - [ ] トランザクション処理
  - [ ] アクション検証
- [ ] ゲームアクションのデータベース保存
  - [ ] game_actionsテーブルへの記録
  - [ ] リプレイ用データ記録
- [ ] 状態変更通知用タイムスタンプ管理

#### 成果物
- ゲームAPI
- GameServiceクラス
- アクション履歴保存

#### リリース内容
- バックエンドでゲームが完全に動作
- すべてのアクションが記録される
- ポーリングでゲーム状態取得可能

#### AI活用ポイント
- Ktor APIエンドポイントの実装
- トランザクション処理
- データ整合性の確保

---

### Phase 15: ゲーム画面の実装 ⏱️ 3時間
**目標**: ゲームプレイ機能の実装

#### 作業内容
- [ ] ゲーム初期化処理
  - [ ] ゲーム開始時の画面遷移
  - [ ] 初期状態の表示
- [ ] カードプレイ機能
  - [ ] カードクリック処理
  - [ ] 出せるカードの判定・ハイライト
  - [ ] カードプレイアニメーション
- [ ] ターン管理
  - [ ] 自分のターンの判定
  - [ ] ターンタイマー表示
  - [ ] 自動ターンスキップ
- [ ] ゲーム状態の表示
  - [ ] 他プレイヤーの手札枚数
  - [ ] 場のカード
  - [ ] ターン表示

#### 成果物
- 動作するゲーム画面
- カードプレイ機能

#### リリース内容
- 実際にゲームがプレイ可能
- カードを出してゲームが進行する

#### AI活用ポイント
- ゲームUIロジックの実装
- アニメーション処理
- 状態同期の実装

---

### Phase 16: ゲームのポーリング同期 ⏱️ 3時間
**目標**: 全プレイヤーでゲーム状態をポーリングで同期

#### 作業内容
- [ ] ゲーム状態ポーリング
  - [ ] useGamePolling カスタムHook
  - [ ] 1秒間隔での状態取得
  - [ ] 差分検知と更新
- [ ] 状態更新処理
  - [ ] 他プレイヤーのアクション反映
  - [ ] ターン変更の検知
  - [ ] 手札・場札の同期
- [ ] アニメーション処理
  - [ ] カードプレイのアニメーション
  - [ ] ターン遷移エフェクト
  - [ ] スムーズな遷移（楽観的UI更新）
- [ ] エラーハンドリング
  - [ ] ポーリング失敗時のリトライ
  - [ ] 接続断時の通知
  - [ ] 状態復元

#### 成果物
- ポーリングベースのゲーム同期
- エラーハンドリング

#### リリース内容
- 複数プレイヤーでゲームが進行
- 1秒程度の遅延で全員の画面が同期
- ネットワークエラーに強い実装

#### AI活用ポイント
- 効率的なポーリング同期ロジック
- 楽観的UI更新の実装
- エラーリカバリー

---

### Phase 17: リザルト画面・統計更新 ⏱️ 3時間
**目標**: ゲーム終了処理と統計

#### 作業内容
- [ ] リザルト画面
  - [ ] 順位表示
  - [ ] 各プレイヤーの統計
  - [ ] 使用ターン数
  - [ ] プレイ時間
- [ ] 統計更新処理
  - [ ] 勝敗記録
  - [ ] 最速記録更新
  - [ ] 総ゲーム数更新
- [ ] リザルトAPI
  - [ ] GET /api/games/:gameId/result
- [ ] 次のアクション
  - [ ] もう一度遊ぶボタン
  - [ ] ロビーに戻るボタン

#### 成果物
- リザルト画面
- 統計更新機能

#### リリース内容
- ゲーム終了後にリザルトが表示される
- プレイヤー統計が正しく更新される

#### AI活用ポイント
- 統計計算ロジック
- リザルト画面のUI実装
- データ集計処理

---

### Phase 18: UI/UX改善・バグフィックス ⏱️ 3時間
**目標**: 全体的なブラッシュアップ

#### 作業内容
- [ ] UIの改善
  - [ ] レスポンシブデザインの調整
  - [ ] アニメーションの改善
  - [ ] ローディング表示の統一
  - [ ] エラーメッセージの改善
- [ ] UXの改善
  - [ ] 操作フィードバックの追加
  - [ ] ツールチップの追加
  - [ ] ショートカットキーの実装
- [ ] バグフィックス
  - [ ] テストで見つかったバグの修正
  - [ ] エッジケースの対応
- [ ] パフォーマンス改善

#### 成果物
- 改善されたUI/UX
- バグフィックス

#### リリース内容
- 洗練されたユーザー体験
- 安定した動作

#### AI活用ポイント
- UIパターンの提案
- バグの原因分析
- パフォーマンスボトルネックの特定

---

### Phase 19: 観戦モード実装 ⏱️ 3時間
**目標**: ゲームの観戦機能

#### 作業内容
- [ ] 観戦モードAPI
  - [ ] GET /api/games/:gameId/spectate
  - [ ] 観戦者の管理
- [ ] 観戦画面
  - [ ] 全プレイヤーの手札を見せない表示
  - [ ] ゲーム進行の表示
  - [ ] リアルタイム同期
- [ ] 観戦者リスト表示
- [ ] 観戦者制限の設定

#### 成果物
- 観戦モード

#### リリース内容
- ゲームを観戦できる機能

#### AI活用ポイント
- 観戦モードの特殊なロジック
- 権限管理の実装

---

### Phase 20: 最終テスト・ドキュメント整備 ⏱️ 3時間
**目標**: リリース準備

#### 作業内容
- [ ] 統合テスト
  - [ ] 全機能のテストシナリオ実行
  - [ ] 複数ユーザーでの動作確認
  - [ ] エッジケースのテスト
- [ ] パフォーマンステスト
  - [ ] 負荷テスト
  - [ ] レスポンスタイム計測
- [ ] ドキュメント整備
  - [ ] README更新
  - [ ] API仕様書の最終確認
  - [ ] デプロイ手順書
  - [ ] トラブルシューティングガイド
- [ ] セキュリティチェック
  - [ ] 脆弱性スキャン
  - [ ] 環境変数の確認

#### 成果物
- テスト完了レポート
- 最新ドキュメント
- リリース準備完了

#### リリース内容
- 本番リリース可能な状態

#### AI活用ポイント
- テストケースの自動生成
- ドキュメントの推敲
- セキュリティチェックリスト

---

## 📊 開発進捗管理

### マイルストーン

#### Milestone 0: 環境構築 (Phase 0-0.5)
- 目標: 開発環境とCI/CD基盤の完成
- 期間: 約5時間（1日）
- 成果物: バックエンドCI/CD、EC2環境、自動停止設定

#### Milestone 1: フロントエンド基礎 (Phase 1-5)
- 目標: モックデータで動作するフロントエンド完成
- 期間: 約15時間（2-3日）
- 成果物: プレイヤー登録、ルーム一覧、ゲーム画面UI

#### Milestone 2: バックエンド基礎 (Phase 6-9)
- 目標: データベース・API基盤の完成
- 期間: 約12時間（1-2日）
- 成果物: DB、プレイヤーAPI、統合

#### Milestone 3: ルーム機能完成 (Phase 10-12)
- 目標: リアルタイムルーム機能の完成
- 期間: 約9時間（1-2日）
- 成果物: ルームAPI、ポーリング、チャット

#### Milestone 4: ゲーム機能完成 (Phase 13-17)
- 目標: ゲームプレイ機能の完成
- 期間: 約15時間（2-3日）
- 成果物: ゲームロジック、ポーリング同期、統計

#### Milestone 5: 仕上げ (Phase 18-20)
- 目標: 本番リリース可能な品質
- 期間: 約9時間（1-2日）
- 成果物: UI/UX改善、観戦モード、テスト完了

### 総開発期間
- **総作業時間**: 約65時間
- **実働日数**: 11〜16日（1日3〜6時間作業想定）
- **カレンダー期間**: 2〜3週間

---

## 🎯 各フェーズの進め方

### 作業前の準備
1. フェーズの目標と成果物を確認
2. 関連ドキュメント（設計書）を確認
3. 必要なツールやライブラリをリストアップ

### 作業中
1. **AIに明確な指示を出す**
   - 設計書の該当箇所を提示
   - 期待する動作を具体的に説明
   - コーディング規約を指定
2. **小さく実装・頻繁にテスト**
   - 機能を小分けにして実装
   - 動作確認を頻繁に行う
   - コミットを細かく行う
3. **時間管理**
   - 3時間を意識
   - 途中で行き詰まったら方針転換

### 作業後
1. **動作確認**
   - すべての成果物が動作することを確認
   - エッジケースも確認
2. **コミット・プッシュ**
   - 意味のある単位でコミット
   - 分かりやすいコミットメッセージ
3. **ドキュメント更新**
   - 実装内容をドキュメントに反映
   - 次フェーズへの引き継ぎ事項をメモ

---

## 🚀 リリース戦略

### 開発環境
- **ローカル**: http://localhost:5173 (Vite Dev Server)
- **API**: http://localhost:3000 (Express)
- **DB**: localhost:5432 (PostgreSQL in Docker)

### ステージング環境
- **フロントエンド**: S3バケット（テスト用）
- **バックエンド**: EC2（開発用）
- **DB**: RDS無料枠（検討）

### 本番環境
- **フロントエンド**: S3 + CloudFront
- **バックエンド**: EC2 t3.micro
- **DB**: EC2内のPostgreSQL（コスト重視）

### デプロイフロー
1. `main`ブランチへのプッシュ
2. AWS CodePipelineが自動起動
3. CodeBuildでビルド
4. S3へデプロイ（フロントエンド）
5. EC2へSSHデプロイ（バックエンド）
6. ヘルスチェック
7. Slack/メールで通知

---

## 📝 コーディング規約

### TypeScript
- **命名規則**
  - コンポーネント: PascalCase
  - 関数: camelCase
  - 定数: UPPER_SNAKE_CASE
  - ファイル名: kebab-case
- **型定義**
  - 明示的な型定義を優先
  - `any`の使用は最小限に
  - interfaceよりtypeを優先
- **コメント**
  - 複雑なロジックには説明を追加
  - JSDocで関数の説明

### React
- **関数コンポーネント**を使用
- **Hooks**を活用
- **propsの型定義**は必須
- **useEffect**の依存配列を適切に設定

### CSS
- **CSS Modules**または**Styled Components**
- **レスポンシブ**: モバイルファースト
- **カラー**: CSS変数で管理

### Git
- **ブランチ戦略**: GitHub Flow
  - `main`: 本番環境
  - `feature/*`: 機能開発
  - `fix/*`: バグ修正
- **コミットメッセージ**: Conventional Commits
  - `feat:` 新機能
  - `fix:` バグ修正
  - `docs:` ドキュメント
  - `style:` スタイル
  - `refactor:` リファクタリング
  - `test:` テスト

---

## ⚠️ リスク管理

### 技術的リスク
| リスク | 影響 | 対策 |
|-------|------|------|
| ポーリングの負荷増大 | 中 | キャッシュ活用、差分返却、ポーリング間隔調整 |
| ポーリング遅延による体験低下 | 中 | 楽観的UI更新、適切な間隔設定（1秒） |
| データベースパフォーマンス | 中 | インデックス最適化、Exposedクエリ改善 |
| EC2のメモリ不足（JVM） | 中 | JVMヒープサイズ調整、スワップ設定 |
| フロントエンドのバンドルサイズ | 低 | Code Splitting、遅延ロード |

### スケジュールリスク
| リスク | 影響 | 対策 |
|-------|------|------|
| 1フェーズが3時間を超過 | 中 | スコープ削減、次フェーズに延期 |
| 複雑な機能で行き詰まり | 高 | シンプルな実装に切り替え、MVP優先 |
| バグ修正に時間がかかる | 中 | 専用のフェーズで対応 |

### 品質リスク
| リスク | 影響 | 対策 |
|-------|------|------|
| テスト不足 | 高 | 各フェーズで動作確認、Phase 20で統合テスト |
| セキュリティ脆弱性 | 高 | 定期的なスキャン、ベストプラクティス遵守 |
| パフォーマンス問題 | 中 | Phase 18で改善、負荷テスト実施 |

---

## 📌 次のアクション

### Phase 0.5から開始（バックエンドCI/CD構築）
1. [x] この開発計画をレビュー
2. [ ] EC2インスタンスの状態確認
3. [ ] JDK 17とGradleのインストール確認
4. [ ] Kotlin + Ktorプロジェクト初期化
5. [ ] CI/CDパイプライン構築
6. [ ] EC2自動停止設定

### 準備事項
- [x] 開発環境の確認
- [ ] 必要なツールのインストール（JDK 17, Gradle, Docker）
- [x] GitHubリポジトリの確認
- [ ] フロントエンドCI/CDパイプラインの確認
- [ ] EC2インスタンスの確認
- [ ] AWSアクセスキーの確認

---

## 💡 AI駆動開発のTips

### 効果的なプロンプト
1. **コンテキストを提供**: 設計書や既存コードを提示
2. **具体的な要求**: 「〇〇を実装して」より「〇〇の機能を、△△のような動作で実装して」
3. **段階的な質問**: 大きな機能は小分けにして質問
4. **エラーは全文提示**: エラーメッセージは省略せずに全文

### AIツールの使い分け
- **GitHub Copilot**: コード補完、定型コード生成（Kotlin対応）
- **ChatGPT/Claude**: ロジック設計、複雑な実装の相談
- **Copilot Chat**: ファイル内での実装相談、リファクタリング
- **Kotlin特有の機能**: データクラス、拡張関数、コルーチンの活用をAIに提案させる

### 確認ポイント
- AIが生成したコードは必ず動作確認
- セキュリティ関連は特に注意深くレビュー
- 複雑なロジックはユニットテストを追加

---

**開発開始日**: 2025年10月12日
**目標完了日**: 2025年10月末〜11月初旬
**現在のフェーズ**: Phase 0.5（バックエンドCI/CD・EC2環境構築）

---

## 📝 Phase 0.5 詳細チェックリスト

### 1. ローカル環境準備
- [ ] JDK 17インストール確認 (`java -version`)
- [ ] Gradleインストール確認 (`gradle -v`)
- [ ] IntelliJ IDEA（またはVS Code + Kotlin拡張）
- [ ] Dockerインストール確認 (`docker -v`)

### 2. Kotlin + Ktorプロジェクト作成
- [ ] `api/`ディレクトリ作成
- [ ] Gradle Kotlin DSLプロジェクト初期化
- [ ] 依存関係追加（Ktor, Logback, Kotlinx.serialization）
- [ ] Application.kt作成（Hello World）
- [ ] application.conf設定
- [ ] ローカルで起動確認（http://localhost:8080/api/hello）

### 3. Docker化
- [ ] Dockerfile作成（マルチステージビルド）
- [ ] .dockerignore作成
- [ ] ローカルでDockerビルド確認
- [ ] ローカルでコンテナ起動確認

### 4. EC2準備
- [ ] EC2インスタンス起動（t3.micro）
- [ ] セキュリティグループ設定
  - [ ] SSH (22) - マイIPのみ
  - [ ] HTTP (80) - 0.0.0.0/0
  - [ ] API (8080) - 0.0.0.0/0
- [ ] SSHキーペア確認
- [ ] Dockerインストール確認（EC2上）
- [ ] デプロイディレクトリ作成

### 5. EC2自動停止設定
- [ ] Lambda関数作成（Python 3.x）
- [ ] IAMロール作成（EC2:StopInstances権限）
- [ ] CloudWatch Eventsルール作成
  - cron(0 20 * * ? *) - UTC 20:00 = JST 5:00
- [ ] 環境変数設定（EC2インスタンスID）
- [ ] テスト実行

### 6. CI/CD構築
- [ ] buildspec-api.yml作成
- [ ] scripts/deploy-api.sh作成
- [ ] docker-compose.prod.yml作成
- [ ] CodePipeline確認・設定
  - [ ] ソース: GitHub (api/**を監視)
  - [ ] ビルド: CodeBuild (buildspec-api.yml)
  - [ ] デプロイ: EC2へSSHデプロイ
- [ ] SSHキーをCodeBuildに設定（Systems Manager Parameter Store）

### 7. 動作確認
- [ ] ローカル: http://localhost:8080/api/hello
- [ ] ローカル: http://localhost:8080/health
- [ ] Gitコミット・プッシュ
- [ ] CodePipeline実行確認
- [ ] 本番: http://EC2_IP:8080/api/hello
- [ ] 本番: http://EC2_IP:8080/health

### 8. ドキュメント更新
- [ ] README.md更新（バックエンド起動方法）
- [ ] API仕様書更新（エンドポイント追加）
- [ ] デプロイ手順書作成

🚀 さあ、開発を始めましょう！
