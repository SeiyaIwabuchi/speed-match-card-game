# バックエンド環境切り替えガイド

Speed Match Card Game バックエンドAPI（Ktor/Kotlin）の環境切り替え方法について説明します。

## 概要

このプロジェクトでは、Ktorの設定機能とGradleのプロファイル機能を使用して、開発・ステージング・本番環境を切り替えることができます。

## 環境設定ファイルの構成

Ktorは以下の順序で設定ファイルを読み込みます（後から読み込まれた設定が優先されます）：

1. `application.conf/yaml` - デフォルト設定
2. `application-{profile}.conf/yaml` - プロファイル別設定
3. 環境変数での上書き

### ファイル構成例

```
api/src/main/resources/
├── application.yaml              # 共通設定
├── application-development.yaml  # 開発環境設定
├── application-staging.yaml      # ステージング環境設定
├── application-production.yaml   # 本番環境設定
└── logback.xml                   # ログ設定
```

## 環境別設定ファイルの例

### `application.yaml` （共通設定）
```yaml
ktor:
    application:
        modules:
            - com.speedmatch.ApplicationKt.module

# アプリケーション共通設定
app:
    name: "Speed Match Card Game API"
    version: "1.0.0"
    
# セキュリティ設定
security:
    jwt:
        # 本番環境では環境変数で上書き
        secret: "default-secret-key"
        issuer: "speedmatch-api"
        audience: "speedmatch-users"
        realm: "speedmatch"
```

### `application-development.yaml` （開発環境）
```yaml
ktor:
    deployment:
        port: 8080
        host: "0.0.0.0"
    development: true

# データベース設定
database:
    driver: "org.h2.Driver"
    url: "jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1"
    user: "sa"
    password: ""
    maxPoolSize: 10

# ログ設定
logging:
    level: "DEBUG"
    
# 外部API設定
external:
    api:
        timeout: 30000
        retries: 3
        
# CORS設定（開発時は緩い設定）
cors:
    allowedHosts: ["localhost:3000", "127.0.0.1:3000"]
    allowCredentials: true
```

### `application-staging.yaml` （ステージング環境）
```yaml
ktor:
    deployment:
        port: 8080
        host: "0.0.0.0"
    development: false

# データベース設定
database:
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://staging-db:5432/speedmatch"
    user: "speedmatch_user"
    password: "${DATABASE_PASSWORD}"
    maxPoolSize: 20

# ログ設定
logging:
    level: "INFO"
    
# 外部API設定
external:
    api:
        timeout: 10000
        retries: 2
        baseUrl: "https://staging-api.example.com"
        
# CORS設定
cors:
    allowedHosts: ["https://staging.speedmatch.com"]
    allowCredentials: true

# モニタリング設定
monitoring:
    enabled: true
    healthCheck:
        interval: 30000
```

### `application-production.yaml` （本番環境）
```yaml
ktor:
    deployment:
        port: 8080
        host: "0.0.0.0"
    development: false

# データベース設定
database:
    driver: "org.postgresql.Driver"
    url: "${DATABASE_URL}"
    user: "${DATABASE_USER}"
    password: "${DATABASE_PASSWORD}"
    maxPoolSize: 50
    connectionTimeout: 5000

# ログ設定
logging:
    level: "WARN"
    
# 外部API設定
external:
    api:
        timeout: 5000
        retries: 1
        baseUrl: "https://api.example.com"
        
# CORS設定
cors:
    allowedHosts: ["https://speedmatch.com"]
    allowCredentials: false

# セキュリティ強化
security:
    jwt:
        secret: "${JWT_SECRET}"
        expirationTime: 3600000
    rateLimit:
        enabled: true
        requestsPerMinute: 100

# モニタリング設定
monitoring:
    enabled: true
    healthCheck:
        interval: 60000
    metrics:
        enabled: true
```

## Gradle設定（シンプル版）

基本的な`build.gradle.kts`の設定：

```kotlin
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.ktor)
    id("application")
}

group = "com.speedmatch"
version = "0.0.1"

application {
    mainClass = "io.ktor.server.netty.EngineMain"
}

dependencies {
    implementation(libs.ktor.server.core)
    implementation(libs.ktor.server.netty)
    implementation(libs.ktor.server.config.yaml)
    implementation(libs.logback.classic)
    
    // 追加の依存関係
    implementation("io.ktor:ktor-server-cors:${libs.versions.ktor.get()}")
    implementation("io.ktor:ktor-server-auth:${libs.versions.ktor.get()}")
    implementation("io.ktor:ktor-server-auth-jwt:${libs.versions.ktor.get()}")
    
    // データベース関連
    implementation("org.postgresql:postgresql:42.6.0")
    implementation("com.h2database:h2:2.2.224")
    implementation("com.zaxxer:HikariCP:5.0.1")
    
    testImplementation(libs.ktor.server.test.host)
    testImplementation(libs.kotlin.test.junit)
}
```

## Kotlinアプリケーションでの設定読み込み

アプリケーションコードで環境設定を利用する方法：

```kotlin
// Application.kt
package com.speedmatch

import io.ktor.server.application.*
import io.ktor.server.config.*

fun Application.module() {
    // 設定値の読み込み
    val config = environment.config
    
    val appName = config.property("app.name").getString()
    val appVersion = config.property("app.version").getString()
    val isDevelopment = config.propertyOrNull("ktor.development")?.getString()?.toBoolean() ?: false
    
    // データベース設定（環境変数での上書きをサポート）
    val dbConfig = DatabaseConfig(
        driver = config.property("database.driver").getString(),
        url = config.property("database.url").getString(),
        user = config.property("database.user").getString(),
        password = config.property("database.password").getString(),
        maxPoolSize = config.property("database.maxPoolSize").getString().toInt()
    )
    
    // ログ出力
    log.info("Starting $appName v$appVersion (development: $isDevelopment)")
    log.info("Database URL: ${dbConfig.url}")
    
    // 設定に基づいたモジュール初期化
    configureRouting()
    configureSecurity(config)
    configureDatabase(dbConfig)
    
    if (isDevelopment) {
        configureDevelopmentFeatures()
    }
}

// 設定データクラス
data class DatabaseConfig(
    val driver: String,
    val url: String,
    val user: String,
    val password: String,
    val maxPoolSize: Int
)

// セキュリティ設定
fun Application.configureSecurity(config: ApplicationConfig) {
    val jwtSecret = config.property("security.jwt.secret").getString()
    val jwtIssuer = config.property("security.jwt.issuer").getString()
    val jwtAudience = config.property("security.jwt.audience").getString()
    
    // JWT設定の実装...
}

// データベース設定
fun Application.configureDatabase(config: DatabaseConfig) {
    // データベース接続の設定...
}

// デバッグ用設定表示
fun Application.debugConfiguration() {
    val config = environment.config
    
    log.info("=== Configuration Debug ===")
    log.info("Port: ${config.propertyOrNull("ktor.deployment.port")?.getString()}")
    log.info("Development mode: ${config.propertyOrNull("ktor.development")?.getString()}")
    log.info("Database URL: ${config.propertyOrNull("database.url")?.getString()}")
    log.info("========================")
}
```

## コマンド使用例

### 開発サーバーの起動

```bash
# 開発環境で起動（デフォルト）
./gradlew run

# ステージング環境で起動
./gradlew run --args='-config=application.yaml -config=application-staging.yaml'

# 本番環境で起動
./gradlew run --args='-config=application.yaml -config=application-production.yaml'
```

### ビルド

```bash
# JAR作成
./gradlew build
```

### JAR実行

```bash
# 開発環境で実行（デフォルト）
java -jar build/libs/api-0.0.1.jar

# ステージング環境で実行
java -jar build/libs/api-0.0.1.jar -config=application.yaml -config=application-staging.yaml

# 本番環境で実行
java -jar build/libs/api-0.0.1.jar -config=application.yaml -config=application-production.yaml

# 環境変数と組み合わせ
DATABASE_PASSWORD=secret java -jar build/libs/api-0.0.1.jar -config=application.yaml -config=application-production.yaml
```

## 環境変数での設定上書き

本番環境では機密情報を環境変数で設定：

```bash
# データベース接続情報
export DATABASE_URL="jdbc:postgresql://prod-db:5432/speedmatch"
export DATABASE_USER="prod_user"
export DATABASE_PASSWORD="secure_password"

# JWT設定
export JWT_SECRET="very-secure-jwt-secret-key"

# プロファイル指定
export PROFILE="production"

# アプリケーション起動
java -jar api-0.0.1.jar
```

## Docker対応

### Dockerfile例

```dockerfile
FROM eclipse-temurin:21-jre-alpine

WORKDIR /app

# 環境変数のデフォルト値
ENV SERVER_PORT=8080

# アプリケーションJARと設定ファイルをコピー
COPY build/libs/api-0.0.1.jar app.jar
COPY src/main/resources/application*.yaml ./

# ポート公開
EXPOSE $SERVER_PORT

# ヘルスチェック
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:$SERVER_PORT/health || exit 1

# デフォルトは開発環境設定で起動
CMD ["java", "-jar", "app.jar"]
```

### docker-compose.yml例

```yaml
version: '3.8'

services:
  api-development:
    build: 
      context: ./api
      dockerfile: Dockerfile
    command: ["java", "-jar", "app.jar"]
    environment:
      - DATABASE_URL=jdbc:h2:mem:testdb
    ports:
      - "8080:8080"
    volumes:
      - ./api/logs:/app/logs

  api-staging:
    build: 
      context: ./api
      dockerfile: Dockerfile
    command: ["java", "-jar", "app.jar", "-config=application.yaml", "-config=application-staging.yaml"]
    environment:
      - DATABASE_URL=jdbc:postgresql://staging-db:5432/speedmatch
      - DATABASE_USER=staging_user
      - DATABASE_PASSWORD=staging_password
    ports:
      - "8081:8080"
    depends_on:
      - staging-db

  api-production:
    build: 
      context: ./api
      dockerfile: Dockerfile
    command: ["java", "-jar", "app.jar", "-config=application.yaml", "-config=application-production.yaml"]
    environment:
      - DATABASE_URL=${PROD_DATABASE_URL}
      - DATABASE_USER=${PROD_DATABASE_USER}
      - DATABASE_PASSWORD=${PROD_DATABASE_PASSWORD}
      - JWT_SECRET=${PROD_JWT_SECRET}
    ports:
      - "8082:8080"
    depends_on:
      - production-db

  staging-db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=speedmatch
      - POSTGRES_USER=staging_user
      - POSTGRES_PASSWORD=staging_password
    volumes:
      - staging_db_data:/var/lib/postgresql/data

  production-db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=speedmatch
      - POSTGRES_USER=${PROD_DATABASE_USER}
      - POSTGRES_PASSWORD=${PROD_DATABASE_PASSWORD}
    volumes:
      - production_db_data:/var/lib/postgresql/data

volumes:
  staging_db_data:
  production_db_data:
```

## CI/CD での活用

### AWS CodeBuild での設定例

```yaml
# buildspec-backend.yml
version: 0.2

phases:
  install:
    runtime-versions:
      java: corretto21
    commands:
      - echo "Installing dependencies..."
      
  pre_build:
    commands:
      - echo "Pre-build phase..."
      - cd api
      - chmod +x gradlew
      - export BUILD_ENV=${BUILD_ENV:-production}
      - echo "Building for $BUILD_ENV environment"
      
  build:
    commands:
      - echo "Building Kotlin/Ktor application..."
      - ./gradlew clean build
      - echo "Build completed on `date`"

artifacts:
  files:
    - 'build/libs/*.jar'
    - 'Dockerfile'
    - 'src/main/resources/application*.yaml'
  base-directory: 'api'
  name: speedmatch-backend-${BUILD_ENV}

cache:
  paths:
    - 'api/.gradle/**/*'
    - 'api/build/tmp/.cache/**/*'
```

### GitHub Actions での設定例

```yaml
# .github/workflows/backend-build.yml
name: Build Backend API

on:
  push:
    branches: [main, develop, staging]
    paths: ['api/**']

jobs:
  build:
    runs-on: ubuntu-latest
        
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
      
      - name: Setup Gradle
        uses: gradle/gradle-build-action@v2
        
      - name: Make gradlew executable
        run: chmod +x api/gradlew
        
      - name: Build application
        run: |
          cd api
          ./gradlew clean build
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: api-jar
          path: |
            api/build/libs/*.jar
            api/src/main/resources/application*.yaml

  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          
      - name: Run tests
        run: |
          cd api
          chmod +x gradlew
          ./gradlew test
          
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: api/build/reports/tests/
```

## ログ設定の環境別切り替え

### logback.xml での環境別設定

```xml
<configuration>
    <!-- プロファイルに応じたログレベル設定 -->
    <springProfile name="development">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
    
    <springProfile name="staging">
        <root level="INFO">
            <appender-ref ref="CONSOLE"/>
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
    
    <springProfile name="production">
        <root level="WARN">
            <appender-ref ref="JSON_FILE"/>
        </root>
    </springProfile>

    <!-- コンソール出力 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- ファイル出力 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxFileSize>100MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{40} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- JSON形式ログ出力（本番環境用） -->
    <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.json</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.%i.json</fileNamePattern>
            <maxFileSize>100MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
            <providers>
                <timestamp/>
                <logLevel/>
                <loggerName/>
                <message/>
                <mdc/>
                <stackTrace/>
            </providers>
        </encoder>
    </appender>
</configuration>
```

## トラブルシューティング

### よくある問題と解決方法

1. **設定ファイルが読み込まれない**
   - ファイル名が正しいか確認（`application-{profile}.yaml`）
   - リソースディレクトリに配置されているか確認
   - プロファイル名が正しく指定されているか確認

2. **環境変数が反映されない**
   - 環境変数名が設定ファイルと一致しているか確認
   - システムプロパティとの競合がないか確認
   - Docker環境では環境変数の継承を確認

3. **データベース接続エラー**
   - 接続文字列が環境に応じて正しく設定されているか確認
   - 認証情報が正しく環境変数に設定されているか確認
   - ネットワーク接続とファイアウォール設定を確認

### デバッグ方法

設定ファイルの読み込み確認：

```bash
# 設定ファイルの読み込み順序を確認
java -jar api-0.0.1.jar -config=application.yaml -config=application-staging.yaml

# ログで読み込まれた設定を確認
# Application.ktにdebugConfiguration()関数を追加して確認
```

コード内での設定値確認：

```kotlin
fun Application.debugConfiguration() {
    val config = environment.config
    
    log.info("=== Configuration Debug ===")
    log.info("Config files loaded: ${environment.config}")
    log.info("Development mode: ${config.propertyOrNull("ktor.development")?.getString()}")
    log.info("Port: ${config.propertyOrNull("ktor.deployment.port")?.getString()}")
    log.info("Database URL: ${config.propertyOrNull("database.url")?.getString()}")
    log.info("========================")
}
```

## セキュリティ注意点

### 重要な注意事項

1. **機密情報の管理**: データベースパスワード、JWTシークレットは環境変数で設定
2. **設定ファイルの暗号化**: 本番環境の設定ファイルは暗号化または外部管理
3. **ログの機密情報**: パスワードやトークンがログに出力されないよう注意
4. **CORS設定**: 環境に応じて適切に制限する

## 主要なコマンド一覧

### 開発時

```bash
# 開発環境（デフォルト）
./gradlew run
java -jar build/libs/api-0.0.1.jar

# ステージング環境
./gradlew run --args='-config=application.yaml -config=application-staging.yaml'
java -jar build/libs/api-0.0.1.jar -config=application.yaml -config=application-staging.yaml

# 本番環境
./gradlew run --args='-config=application.yaml -config=application-production.yaml'
java -jar build/libs/api-0.0.1.jar -config=application.yaml -config=application-production.yaml
```

### Docker

```bash
# 開発環境
docker run speedmatch-api

# ステージング環境
docker run speedmatch-api java -jar app.jar -config=application.yaml -config=application-staging.yaml

# 本番環境
docker run speedmatch-api java -jar app.jar -config=application.yaml -config=application-production.yaml
```

## まとめ

この**シンプルなバックエンド環境切り替えシステム**により、以下のメリットを得られます：

- **標準的な方法**: Ktorの標準的な`-config`オプションを使用
- **シンプルな構成**: カスタムGradleタスク不要で保守性向上
- **柔軟な設定**: 複数の設定ファイルを組み合わせて環境を構築
- **環境変数対応**: 機密情報は環境変数で安全に上書き
- **CI/CD対応**: 標準的なビルドプロセスで自動化が容易

Ktorの標準機能を活用することで、シンプルで理解しやすい環境管理が実現できます。